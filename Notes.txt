# npm init

# We keep files on server then--> upload to 3rd party 
# git not track empty Folders so use: .gitkeep
 public/temp/.gitkeep

1. .gitignore generator: https://mrkandreev.name/snippets/gitignore-generator/

2. .env environment are taken from system not from 

3. HotReloading we have problem we whenever make changes we have to start and stop server... so to encouter this problem we use: nodemon
4. Nodemon task is to restart the server when ever me save the file after changing
   dev dependency :- only work on dev mode not get to production time

5. npm i -D nodemon 
   script :{ "dev": "nodemon index.js"}

6. mkdir controllers db middlewares models routes utils

7. for to avoid conflicts during merge use:
   npm i -D prettier
  
8. File:
  .prettierrc :
  {
    "singleQuote": true,
    "bracketSpacing": true,
    "tabWidth": 2,
    "trailingComma": "es5",
    "semi": true
 }

 .prettierignore
/.vscode
/node_modules
./dist

*.env
.env
.env.*


#--------------------------------------------#

Connecting with Mongodb

1. create account-> create cluster -> go to security -> network access -> provide ip address(generally this is the ip address of srever machine run(only our server can access the db)) we give 0.0.0.0(excess to every one)

2. create user also on same tab of scurity if not created give username passoword(avoid using special characters).

3. connect with cluster it will provide you a string and put it in env file add your password in that connection string.

4. now we need to install :- dotenv,express,mongoose

5. Approach 1: index.js directly write using IIFE
   Approach 2:db/db.js and export function to index
   syntax:
   const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`);


6. Advices: use try catch, async await, check your connection string , import may have problem like db ❌  db.js ✅   

#---------------------------------------#
Express

1. in app.js we use express 
2. and app.listen will be in index.js using .then() after db connection function runs, its returns promise.

Now app.js express work 

3. documentation read , we mainly learn for request and response

4. Request: req.cookies,req.params

5. installing CORS and COOKIES Parser   (app.use() //middleware)

6. Now import both and using cors with app.use(cors({ origin:*, }))

7. Some configurations: (do with app.use(____)) 
   
   -> (express.json({limit:"16kb"}))

   -> (express.urlencoded(
     {
        extended: true, limit: "16kb"
     }
     )) 
     
     //accept the data from url like what will be ... /abdul samad -> /abdul%samad or /abdul+samad any from will be accepted


   > (express.static("public")) use to store files on own server: public assest ,example: favicon

   > (cookiesParser()) help to perform crud operation on cookies

8. we have actually 4 thing (err,req,resp,next) 

9. Standardisation of Error and Response by making class and extend Error to add your own thing and inheirt from it

#--------------------------------------------------------------------#

Working on User Model & JWT

1. make user.model.js and video.js linked to each other 
2. installed mongoose-aggregrate-pagenate 

3. install bcrypt or bcryptjs we are using bcrypt : library to just hash your password and compare { bcrypt.hash(password,rounds) and bcrypt.compare(password,otherpassowrd)}

4. install jwt , jwt is bearer token, who have it is authentic 

5. we use Hooks of Mongoose (like middleware):- Pre(when want to do just before saving or doing soemthing on db do task), Post..etc 
6. Using Pre: when user signUp we use Pre to encrypt password before saving 

7. userSchema.pre("<beforetask>",callback) 

   <beforetask> Ex : save, validate, remove, updateOne, deleteOne

   callback should be like function(next){} because we want "this" context

-> Code:

   userSchema.pre("save", async function (next) {

      if(!this.isModified("password")) return //do this only if password is saved again not for every fields

      this.password=bcrypt.hash(this.password,10)
      next()
})

8. can also make method using userSechma.methods. in model
 
-> userSchema.methods.isPasswordCorrect = async function (password) {
      return await bcrypt.compare(password, this.password)

   }

9. Talking about Access Token(jwt) ,Refresh Token(also jwt)  and there Expiry stored in env.

   ->   jwt.sign(
              payload ,   //can be object or anything
              secret,
              {
                 expiresIn:1d
              }
           
         )
