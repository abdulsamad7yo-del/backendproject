# npm init

# We keep files on server then--> upload to 3rd party 
# git not track empty Folders so use: .gitkeep
 public/temp/.gitkeep

1. .gitignore generator: https://mrkandreev.name/snippets/gitignore-generator/

2. .env environment are taken from system not from 

3. HotReloading we have problem we whenever make changes we have to start and stop server... so to encouter this problem we use: nodemon
4. Nodemon task is to restart the server when ever me save the file after changing
   dev dependency :- only work on dev mode not get to production time

5. npm i -D nodemon 
   script :{ "dev": "nodemon index.js"}

6. mkdir controllers db middlewares models routes utils

7. for to avoid conflicts during merge use:
   npm i -D prettier
  
8. File:
  .prettierrc :
  {
    "singleQuote": true,
    "bracketSpacing": true,
    "tabWidth": 2,
    "trailingComma": "es5",
    "semi": true
 }

 .prettierignore
/.vscode
/node_modules
./dist

*.env
.env
.env.*


#--------------------------------------------#

Connecting with Mongodb

1. create account-> create cluster -> go to security -> network access -> provide ip address(generally this is the ip address of srever machine run(only our server can access the db)) we give 0.0.0.0(excess to every one)

2. create user also on same tab of scurity if not created give username passoword(avoid using special characters).

3. connect with cluster it will provide you a string and put it in env file add your password in that connection string.

4. now we need to install :- dotenv,express,mongoose

5. Approach 1: index.js directly write using IIFE
   Approach 2:db/db.js and export function to index
   syntax:
   const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`);


6. Advices: use try catch, async await, check your connection string , import may have problem like db ❌  db.js ✅   

#---------------------------------------#
Express

1. in app.js we use express 
2. and app.listen will be in index.js using .then() after db connection function runs, its returns promise.

Now app.js express work 

3. documentation read , we mainly learn for request and response

4. Request: req.cookies,req.params

5. installing CORS and COOKIES Parser   (app.use() //middleware)

6. Now import both and using cors with app.use(cors({ origin:*, }))

7. Some configurations: (do with app.use(____)) 
   
   -> (express.json({limit:"16kb"}))

   -> (express.urlencoded(
     {
        extended: true, limit: "16kb"
     }
     )) 
     
     //accept the data from url like what will be ... /abdul samad -> /abdul%samad or /abdul+samad any from will be accepted


   > (express.static("public")) use to store files on own server: public assest ,example: favicon

   > (cookiesParser()) help to perform crud operation on cookies

8. we have actually 4 thing (err,req,resp,next) 

9. Standardisation of Error and Response by making class and extend Error to add your own thing and inheirt from it

#--------------------------------------------------------------------#

Working on User Model & JWT

1. make user.model.js and video.js linked to each other 
2. installed mongoose-aggregrate-pagenate 

3. install bcrypt or bcryptjs we are using bcrypt : library to just hash your password and compare { bcrypt.hash(password,rounds) and bcrypt.compare(password,otherpassowrd)}

4. install jwt , jwt is bearer token, who have it is authentic 

5. we use Hooks of Mongoose (like middleware):- Pre(when want to do just before saving or doing soemthing on db do task), Post..etc 
6. Using Pre: when user signUp we use Pre to encrypt password before saving 

7. userSchema.pre("<beforetask>",callback) 

   <beforetask> Ex : save, validate, remove, updateOne, deleteOne

   callback should be like function(next){} because we want "this" context

-> Code:

   userSchema.pre("save", async function (next) {

      if(!this.isModified("password")) return //do this only if password is saved again not for every fields

      this.password=bcrypt.hash(this.password,10)
    
})

8. can also make method using userSechma.methods. in model
 
-> userSchema.methods.isPasswordCorrect = async function (password) {
      return await bcrypt.compare(password, this.password)

   }

9. Talking about Access Token(jwt) ,Refresh Token(also jwt)  and there Expiry stored in env.

   ->   jwt.sign(
              payload ,   //can be object or anything
              secret,
              {
                 expiresIn:1d
              }
           
         )

#--------------------------------------------------#
Cloudinary & multer

- we can also use express fileupload but we are using multer

- cloudinary is 3rd party to store images and videos.
- multer is middleware to handle multipart form data(when we upload file using form) hand file to cloudinary
# Flow:
   - We take file thrrough multer and temprorary store on local server
   - From local storage we take file and upload to cloudinary
   - ( Why storing on local server : it help in reuploading if any failure occur during upload to cloudinary)

- create utils/cloudinary.js
  cloudinary needs path of file to upload so we use fs module of nodejs to read file from local storage and give path to cloudinary

import fs from 'fs';
  
   - it is a file system module helps to work with files. Read about it on nodejs doc.
   - Some important methods:
      - fs.unlinkSync(path) : delete file on given path (in os files are link and unlink means delete the link to file so file is deleted)
      - fs.readFileSync(path) : read file on given path
      - fs.writeFileSync(path,data) : write data to file on given path

import { v2 as cloudinary } from 'cloudinary';

save cloudnaame,apikey,apisecret in env file and access here using process.env

now code:

1. we have done configuration of cloudinary
2. we make function to upload file to cloudinary:

export const uploadToCloudinary = async (filePath, folder, resourceType) => {
  try {
    const result = await cloudinary.uploader.upload(filePath, 
    // options learned from docs
    {
      folder: folder,
      resource_type: resourceType, // image, video, raw
    });


    return result.url;

  } catch (error) {
    // Delete the local file in case of an error as well
    fs.unlinkSync(filePath);
    throw error;
  }
};

----------
Middleware folder

1. create multer.middleware.js

DOCS:

import multer from 'multer';

const multer = require('multer');
const uploaD = multer({ dest: 'uploads/' }); //destination folder

app.use(uploaD.single('file')); //for Single file upload with field name 'file'

or

// array of files with field name 'files' and max count 10

          //route   // file upload middleware  // controller
app.post('/upload', uploaD.array('files', 10), (req, res) => {
  // Handle the uploaded files in req.files
});

or 

uploaD.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'gallery', maxCount: 8 }
]) 

// for multiple fields with different names

To Save :
1. DiskStorage: to give custom file name and destination
2. MemoryStorage: to save in memory as buffer // Not recommended for large files

DiskStorage Example:

import multer from 'multer';

const storage = multer.diskStorage({

    // file use given by multer
    destination: function (req, file, cb) {
        cb(null, './public/temp'); // specify the destination directory
    },

    filename: function (req, file, cb) {
        
        // const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9); // unique file name
        // console.log(file);
        
        cb(null,file.originalname); // set the file name original name as userd file name;
        
    }

});

const upload = multer({ storage: storage });

export { upload }; 

#----------------------------------------------#

                     HTTPS

- Hypertext Transfer Protocol (HTTP): trnasfer data over the web
- Https is secure version of http use TLS/SSL to encrypt data.
- HTTPS use port 443 and HTTP use port 80

- Http headers: metadata about request and response
  - caching,content-type,authorization,cookie
     old : X-prefix -> deprecated

  - Request headers: sent by client to server
  - Response headers: sent by server to client
  - Representation headers: encoding/compression of data
  - Payload headers: data 

Most Common Header:
 1. Accept:application/json
 2. Content-Type
 3. Authorization: Bearer <token>
 4. Cookie: key=value; key2=value2
 5. Cache-Control: no-cache
 6. User-Agent: Mozilla/5.0  // help to get user browser info

For CORS:
   1. Access-Control-Allow-Origin: *
   2. Access-Control-Allow-Methods: GET,POST,PUT,DELETE
   3. Access-Control-Allow-Headers: Content-Type,Authorization

Security:
 1. Cross-Origin-Embedding-Policy: require-corp
 2. Cross-Origin-Opener-Policy: same-origin
 3. X-XSS-Protection: 1; mode=block
 4. X-Content-Type-Options: nosniff


HTTP Methods:
 1. GET: fetch data
 2. POST: create data
 3. PUT: update data
 4. DELETE: delete data
 5. PATCH: partial update
 6. OPTIONS: preflight request (what methods are allowed)
 7. HEAD: fetch headers only
 8. TRACE: echo back request (for debugging)

Status Codes:
 1xx : Informational
 2xx : Success
 3xx : Redirection
 4xx : Client Error
 5xx : Server Error

 100 : Continue
 102 : Processing
 200 : OK
 201 : Created
 204 : No Content
 300 : Multiple Choices
 309 : Conflict
 400 : Bad Request
 401 : Unauthorized
 403 : Forbidden
 404 : Not Found
 500 : Internal Server Error
 502 : Bad Gateway
 504 : Gateway Timeout

Short Notes:

1. HTTP is stateless protocol
2. Client send request to server
3. Server process request and send response
4. Client process response and display to user
5. Each request is independent of other request
6. To maintain state we use cookies,session,jwt
7. HTTP methods: GET,POST,PUT,DELETE,PATCH,OPTIONS,HEAD
8. HTTP status codes: 1xx,2xx,3xx,4xx,5xx
9. HTTP headers: key-value pairs sent in request and response

RESTful API: Representational State Transfer
11. RESTful API principles:
      - Stateless
      - Client-Server architecture
      - Uniform interface
      - Resource-based
      - Use of HTTP methods
      - Use of HTTP status codes
      - HATEOAS (Hypermedia as the Engine of Application State)

12. RESTful API design:
      - Use nouns for resources
      - Use plural nouns for resource collections
      - Use HTTP methods to perform actions on resources
      - Use query parameters for filtering, sorting, and pagination
      - Use proper HTTP status codes in responses

13. Example of RESTful API endpoints for a User resource:
      - GET /users - Get all users  
      - GET /users/:id - Get a user by ID
      - POST /users - Create a new user
      - PUT /users/:id - Update a user by ID
      - DELETE /users/:id - Delete a user by ID

14. Tools for testing RESTful APIs: Postman, Insomnia, curl

15. Documentation for RESTful APIs: Swagger, OpenAPI
16. Versioning of RESTful APIs: URI versioning, Header versioning, Query parameter

#--------------------------------------------------#
                  Router and Controller

1. Making controller folder and user.controller.js
   we have earlier made asyncHandler.js in utils to handle async errors, just a wrapper function to handle try catch

2. In user.controller.js we make registerUser function and export it.
   
   import {asyncHandler} from '../utils/asyncHandler.js';

    const registerUser = asyncHandler(async (req, res) => {
        res.status(200).jsson({
            message:"OK"
        })
    } );

    export { registerUser };

3. Now make user.routes.js in routes folder

   import {Router} from 'express';

   const router = Router();

   // /api/v1/users/register

   import { registerUser } from '../controllers/user.controller.js';
   router.route("/register").post(registerUser);

    export default router;

4. Now in app.js we import userRouter and use it

   import userRouter from "./routes/user.routes.js"

   // routes declaration
- we are not using app.get("/users",...) because we want to keep our routes in separate file for better management
- so when all thing are seprate like routes,controllers,models it is called MVC architecture(Model View Controller)
- we have to use router middleware that is app.use()
  
   app.use("/api/v1/users", userRouter) 

5. Now run Server and user PostMan to post request to /api/v1/users/register  

Flow : index.js and db.js -> app.js(/api/v1/user) -> user.routes.js(/register) -> user.controller.js 

#--------------------------------------------------#

Writing Actual Controller Logic and Routes

1. Register User controller logic:
  - get user details  from frontend
  - validation - not empty, check if user already exists(username and email) 
  - check for images, check for avatar because required
  - upload to cloudinary (gives response we have to store url)
  - create user object-- create entry in db
  - response(remove password and refresh token from response) 
  - check for user creation success or not
  - send response 

2. We access req.body (it was parsed by middleware app.use(express.json())) , we only now doing for json data if we want to access form data we use app.use(express.urlencoded({extended:true})) so select raw->JSON in Postman

3. Now File handling Avatar:
   
   in user.routes.js
   import { upload } from '../middlewares/multer.middleware.js';

   In route:
   
   router.route("/register").post(
       upload.fields([
         {
            name:"",
            maxCount:1

         },
         {

         }
       ]),  //fields bc we may have multiple files with different field names
       registerUser
   );

   types:
   upload.single('avatar') // for single file with field name avatar
   upload.array('photos', 10) // for multiple files with same field name photos and max count 10
   upload.fields([
       { name: 'avatar', maxCount: 1 },
       { name: 'gallery', maxCount: 8 }
   ])

4. Now back to conroller 
   
   we now do validation and For Error we used Our APIError class made earlier
   
   import { APIError } from '../utils/APIError.js';

   if (username==" ) {
       throw new APIError(400,"Provide username");
   }

   API error have : 
        statusCode,
        message="Something went worng",
        errors=[],
        stack=""

so we can provide status code and message
 it extends Error class so it have all properties of Error class and throw error from it 

5. Now check if user already exists using User model we made earlier

   import { User } from '../models/user.model.js';

   const existingUser = await User.findOne({ $or: [ { email }, { userName } ] });

   if (existingUser) {
       throw new APIError(409, "User already exists with given email or username");
   }

6. Now Files handling:

    // access files with help of multer middleware
    // So here multer have uplaoded the files to local server and we acces using req.files
    // now we get the path of file
    // console.log(req?.files);
    
    const avatarLocalPath = req.files?.avatar[0]?.path
    const coverImageLocalPath = req.files?.coverImage?.[0]?.path

    // avater is required

    if(!avatarLocalPath){
        throw new ApiError(400,"Avatar is required")
    }

7. Create User using User
   
   const user = await User.create({
        fullName,
        userName: userName.toLowerCase(),
        email,
        avatar: avatar.url,
        // optional so can be empty
        coverImage: coverImage?.url || "",
        password
    })

8. Check for user creation success and remove password and refresh token
    const createdUser = await User.findById(user._id).select(
        // we write what we dont want 
        "-password -refreshToken"
    )

    if (!createdUser) {
        throw new ApiError(500, "User registration failed")
    }
 
9. Response:

    // using ApiResponse have (statusCode,data,message)

    return res.status(201).json(
        new ApiResponse(200,createdUser,"User registered successfully",)
    )

#--------------------------------------------------#

Checking and Debugging & PostMan Professional way

1. In user.controller.js we can use console.log at various places to check the flow and data
2. add fs.unlinkSync(localfilePath); after successful upload to cloudinary to delete local file and save space
3. Typo mistakes are common so check carefully.

PostMan Professional way:
1. Use Environments: create environment for dev,prod etc and store variables like baseUrl
   - In url use {{baseUrl}}/api/v1/users/register
   - In env set baseUrl=http://localhost:8000 for 

2. Create Collections: group related requests
   - Create collection "User API"
   - Add request to collection.


3. Use Pre-request Scripts: run scripts before request
   - Generate auth tokens
4. Use Tests: write tests to validate response
   - pm.test("Status code is 201", function () {
       pm.response.to.have.status(201);
     });
5. Use Variables: store reusable values
   - {{userId}}, {{authToken}}
6. Documentation: generate API docs
   - Share with team
   - Monitor: schedule requests"

#--------------------------------------------------#
Login & Access Token and Refresh Token 

1. Access Token: short-lived token to access protected resources
   - Sent in Authorization header as Bearer token
   - Valid for few minutes to hours
   - Used to authenticate API requests

2. Refresh Token: long-lived token to obtain new access tokens
   - Sent in HttpOnly cookie
   - Valid for days to months
   - Used to get new access token when it expires

Flow: Login:
      ->Send Access Token in response body and Refresh Token in HttpOnly Cookie (store in db also)
      ->Client store Access Token in memory and use it in Authorization header for protected requests
      ->When Access Token expires Client send request to refresh endpoint with Refresh Token cookie
      ->Server verify Refresh Token (from db) and send new Access Token in response body.
      ->Repeat.
   
   const options = {
        httpOnly: true, //only modified by server,
        secure: true, // only send on https
    }

    return res
        .status(200)
        .cookie("accessToken", accessToken, options)
        .cookie("refreshToken", refreshToken, options)
        .json(
            new ApiResponse(200, { user: loggedInUser, accessToken, refreshToken }, "User logged in successfully")
        )


* Check user.controller.js for loginUser function implementation
* Go through mongoose methods and middleware in mongoose for better understanding. 

#--------------------------------------------------#

LogOut & Middleware

Ways to logOut User:
- (WEB) Remove Cookies: clear auth cookies on client side.
- Invalidate Tokens: remove refresh token from database.
- (APP) Client-side Cleanup: clear local storage/session storage.

?? if Using Access and Refresh we have to make db call But How we will Get User who is logged in?
- if we make it like form and which gives us email (by which we can find user in db) and refresh token in cookie but it is not secure because anyone can call this api with any email and logout user.

Here Middleware come into picture:

- We have "cookiesParser" middleware to parse cookies from request headers.
- So we can access cookies using req.cookies and res.cookies both.

- Now we make auth.middleware.js in middlewares folder to verify (DECODE) JWT from cookies.
- AccessToken have many things in it we signed like { _id, email, userName, fullName }
- So we can just decode( jwt.verify() gives decoded data) it.
- and get user _id 

- we after verifing we take _id can get  user from db 
- and add that user to req:  req.user = user
- and at last of middleware function always write :  next() 

next() // tells now my work is done go to next function given

How to use Middleware function
- in user.routes.js:
   
   - // secured routes
                                 // next----->   
     router.route("/logout").post(verifyJWT, logOutUser)

   - we can write as many as middleware in between but should check order of Writing
     post.(mid1,mid2,mid3,finalfunction)  
   - // same request pass to all can be modified by previous middleware

#--------------------------------------------------------------------------#

-We now check above code in PostMan
 - So its the same process as reqgister you can also do login using "raw" because we used form in register due to File uplaod. (gives all data + accessToken and refreshToken)
 - And For LogOut , we have to put AccessToken in Authorization : --> Bearer --> <accessToken> in PostMan.
 - You can also check Cookies in PostMan

 More About AccessToken and RefreshToken:
  1. AccessToken and RefreshToken are genrated when user login
  2. AccessToken is given to User and Its short lived and help in access any service by user
  3. RefreshToken is stored in db and long lived and help in to provide user New accessToken when expired.

  both help user to access service and logout without require of user data 
  1. So whenever user accessToken expired -> frontend engg. do i request to server asking for new refreshToken-> if there is refersh token (that is user was logged in and session (refershToken not expired) ) presenent it will provide new access token to user
  2. If user want to logout , user need not to send its email or id , we can just :
     - get user AccessToken from either cookies (if added by server at the time of login) or req.header(" Authorization").split(" ").[1]
     - and decode that accessToken(by jwt.verify() ) giving us data we signed with (user :_id) 
     - _id can be used to get that user and then 
           i. Remove RefreshToken from db.
           ii. clearCookies from res

#----------------------------------------------------------------------#

End Point to refreshAccessToken in user.controller.js:
 - we firts get refresh token from cookeis or body (id frontend engg send in that)
 - we will decode it to get _id 
 - then check if refreshToken is present or not 
 - if yes we genrate access token
 - and in reseponse we set accessToken, refershToken and json reseponse
  



