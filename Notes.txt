# npm init

# We keep files on server then--> upload to 3rd party 
# git not track empty Folders so use: .gitkeep
 public/temp/.gitkeep

1. .gitignore generator: https://mrkandreev.name/snippets/gitignore-generator/

2. .env environment are taken from system not from 

3. HotReloading we have problem we whenever make changes we have to start and stop server... so to encouter this problem we use: nodemon
4. Nodemon task is to restart the server when ever me save the file after changing
   dev dependency :- only work on dev mode not get to production time

5. npm i -D nodemon 
   script :{ "dev": "nodemon index.js"}

6. mkdir controllers db middlewares models routes utils

7. for to avoid conflicts during merge use:
   npm i -D prettier
  
8. File:
  .prettierrc :
  {
    "singleQuote": true,
    "bracketSpacing": true,
    "tabWidth": 2,
    "trailingComma": "es5",
    "semi": true
 }

 .prettierignore
/.vscode
/node_modules
./dist

*.env
.env
.env.*


#--------------------------------------------#

Connecting with Mongodb

1. create account-> create cluster -> go to security -> network access -> provide ip address(generally this is the ip address of srever machine run(only our server can access the db)) we give 0.0.0.0(excess to every one)

2. create user also on same tab of scurity if not created give username passoword(avoid using special characters).

3. connect with cluster it will provide you a string and put it in env file add your password in that connection string.

4. now we need to install :- dotenv,express,mongoose

5. Approach 1: index.js directly write using IIFE
   Approach 2:db/db.js and export function to index
   syntax:
   const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`);


6. Advices: use try catch, async await, check your connection string , import may have problem like db ❌  db.js ✅   

#---------------------------------------#
Express

1. in app.js we use express 
2. and app.listen will be in index.js using .then() after db connection function runs, its returns promise.

Now app.js express work 

3. documentation read , we mainly learn for request and response

4. Request: req.cookies,req.params

5. installing CORS and COOKIES Parser   (app.use() //middleware)

6. Now import both and using cors with app.use(cors({ origin:*, }))

7. Some configurations: (do with app.use(____)) 
   
   -> (express.json({limit:"16kb"}))

   -> (express.urlencoded(
     {
        extended: true, limit: "16kb"
     }
     )) 
     
     //accept the data from url like what will be ... /abdul samad -> /abdul%samad or /abdul+samad any from will be accepted


   > (express.static("public")) use to store files on own server: public assest ,example: favicon

   > (cookiesParser()) help to perform crud operation on cookies

8. we have actually 4 thing (err,req,resp,next) 

9. Standardisation of Error and Response by making class and extend Error to add your own thing and inheirt from it

#--------------------------------------------------------------------#

Working on User Model & JWT

1. make user.model.js and video.js linked to each other 
2. installed mongoose-aggregrate-pagenate 

3. install bcrypt or bcryptjs we are using bcrypt : library to just hash your password and compare { bcrypt.hash(password,rounds) and bcrypt.compare(password,otherpassowrd)}

4. install jwt , jwt is bearer token, who have it is authentic 

5. we use Hooks of Mongoose (like middleware):- Pre(when want to do just before saving or doing soemthing on db do task), Post..etc 
6. Using Pre: when user signUp we use Pre to encrypt password before saving 

7. userSchema.pre("<beforetask>",callback) 

   <beforetask> Ex : save, validate, remove, updateOne, deleteOne

   callback should be like function(next){} because we want "this" context

-> Code:

   userSchema.pre("save", async function (next) {

      if(!this.isModified("password")) return //do this only if password is saved again not for every fields

      this.password=bcrypt.hash(this.password,10)
      next()
})

8. can also make method using userSechma.methods. in model
 
-> userSchema.methods.isPasswordCorrect = async function (password) {
      return await bcrypt.compare(password, this.password)

   }

9. Talking about Access Token(jwt) ,Refresh Token(also jwt)  and there Expiry stored in env.

   ->   jwt.sign(
              payload ,   //can be object or anything
              secret,
              {
                 expiresIn:1d
              }
           
         )

#--------------------------------------------------#
Cloudinary & multer

- we can also use express fileupload but we are using multer

- cloudinary is 3rd party to store images and videos.
- multer is middleware to handle multipart form data(when we upload file using form) hand file to cloudinary
# Flow:
   - We take file thrrough multer and temprorary store on local server
   - From local storage we take file and upload to cloudinary
   - ( Why storing on local server : it help in reuploading if any failure occur during upload to cloudinary)

- create utils/cloudinary.js
  cloudinary needs path of file to upload so we use fs module of nodejs to read file from local storage and give path to cloudinary

import fs from 'fs';
  
   - it is a file system module helps to work with files. Read about it on nodejs doc.
   - Some important methods:
      - fs.unlinkSync(path) : delete file on given path (in os files are link and unlink means delete the link to file so file is deleted)
      - fs.readFileSync(path) : read file on given path
      - fs.writeFileSync(path,data) : write data to file on given path

import { v2 as cloudinary } from 'cloudinary';

save cloudnaame,apikey,apisecret in env file and access here using process.env

now code:

1. we have done configuration of cloudinary
2. we make function to upload file to cloudinary:

export const uploadToCloudinary = async (filePath, folder, resourceType) => {
  try {
    const result = await cloudinary.uploader.upload(filePath, 
    // options learned from docs
    {
      folder: folder,
      resource_type: resourceType, // image, video, raw
    });


    return result.url;

  } catch (error) {
    // Delete the local file in case of an error as well
    fs.unlinkSync(filePath);
    throw error;
  }
};

----------
Middleware folder

1. create multer.middleware.js

DOCS:

import multer from 'multer';

const multer = require('multer');
const uploaD = multer({ dest: 'uploads/' }); //destination folder

app.use(uploaD.single('file')); //for Single file upload with field name 'file'

or

// array of files with field name 'files' and max count 10

          //route   // file upload middleware  // controller
app.post('/upload', uploaD.array('files', 10), (req, res) => {
  // Handle the uploaded files in req.files
});

or 

uploaD.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'gallery', maxCount: 8 }
]) 

// for multiple fields with different names

To Save :
1. DiskStorage: to give custom file name and destination
2. MemoryStorage: to save in memory as buffer // Not recommended for large files

DiskStorage Example:

import multer from 'multer';

const storage = multer.diskStorage({

    // file use given by multer
    destination: function (req, file, cb) {
        cb(null, './public/temp'); // specify the destination directory
    },

    filename: function (req, file, cb) {
        
        // const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9); // unique file name
        // console.log(file);
        
        cb(null,file.originalname); // set the file name original name as userd file name;
        
    }

});

const upload = multer({ storage: storage });

export { upload }; 
